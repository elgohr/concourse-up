// Code generated by counterfeiter. DO NOT EDIT.
package iaasfakes

import (
	"sync"

	"github.com/EngineerBetter/concourse-up/iaas"
)

type FakeIClient struct {
	IaaSStub        func() string
	iaaSMutex       sync.RWMutex
	iaaSArgsForCall []struct{}
	iaaSReturns     struct {
		result1 string
	}
	iaaSReturnsOnCall map[int]struct {
		result1 string
	}
	RegionStub        func() string
	regionMutex       sync.RWMutex
	regionArgsForCall []struct{}
	regionReturns     struct {
		result1 string
	}
	regionReturnsOnCall map[int]struct {
		result1 string
	}
	DeleteVMsInVPCStub        func(vpcID string) error
	deleteVMsInVPCMutex       sync.RWMutex
	deleteVMsInVPCArgsForCall []struct {
		vpcID string
	}
	deleteVMsInVPCReturns struct {
		result1 error
	}
	deleteVMsInVPCReturnsOnCall map[int]struct {
		result1 error
	}
	FindLongestMatchingHostedZoneStub        func(subDomain string) (string, string, error)
	findLongestMatchingHostedZoneMutex       sync.RWMutex
	findLongestMatchingHostedZoneArgsForCall []struct {
		subDomain string
	}
	findLongestMatchingHostedZoneReturns struct {
		result1 string
		result2 string
		result3 error
	}
	findLongestMatchingHostedZoneReturnsOnCall map[int]struct {
		result1 string
		result2 string
		result3 error
	}
	MockProviderStub        func(interface{})
	mockProviderMutex       sync.RWMutex
	mockProviderArgsForCall []struct {
		arg1 interface{}
	}
	DeleteVersionedBucketStub        func(name string) error
	deleteVersionedBucketMutex       sync.RWMutex
	deleteVersionedBucketArgsForCall []struct {
		name string
	}
	deleteVersionedBucketReturns struct {
		result1 error
	}
	deleteVersionedBucketReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteFileStub        func(bucket, path string) error
	deleteFileMutex       sync.RWMutex
	deleteFileArgsForCall []struct {
		bucket string
		path   string
	}
	deleteFileReturns struct {
		result1 error
	}
	deleteFileReturnsOnCall map[int]struct {
		result1 error
	}
	EnsureBucketExistsStub        func(name string) error
	ensureBucketExistsMutex       sync.RWMutex
	ensureBucketExistsArgsForCall []struct {
		name string
	}
	ensureBucketExistsReturns struct {
		result1 error
	}
	ensureBucketExistsReturnsOnCall map[int]struct {
		result1 error
	}
	EnsureFileExistsStub        func(bucket, path string, defaultContents []byte) ([]byte, bool, error)
	ensureFileExistsMutex       sync.RWMutex
	ensureFileExistsArgsForCall []struct {
		bucket          string
		path            string
		defaultContents []byte
	}
	ensureFileExistsReturns struct {
		result1 []byte
		result2 bool
		result3 error
	}
	ensureFileExistsReturnsOnCall map[int]struct {
		result1 []byte
		result2 bool
		result3 error
	}
	HasFileStub        func(bucket, path string) (bool, error)
	hasFileMutex       sync.RWMutex
	hasFileArgsForCall []struct {
		bucket string
		path   string
	}
	hasFileReturns struct {
		result1 bool
		result2 error
	}
	hasFileReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	LoadFileStub        func(bucket, path string) ([]byte, error)
	loadFileMutex       sync.RWMutex
	loadFileArgsForCall []struct {
		bucket string
		path   string
	}
	loadFileReturns struct {
		result1 []byte
		result2 error
	}
	loadFileReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	WriteFileStub        func(bucket, path string, contents []byte) error
	writeFileMutex       sync.RWMutex
	writeFileArgsForCall []struct {
		bucket   string
		path     string
		contents []byte
	}
	writeFileReturns struct {
		result1 error
	}
	writeFileReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIClient) IaaS() string {
	fake.iaaSMutex.Lock()
	ret, specificReturn := fake.iaaSReturnsOnCall[len(fake.iaaSArgsForCall)]
	fake.iaaSArgsForCall = append(fake.iaaSArgsForCall, struct{}{})
	fake.recordInvocation("IaaS", []interface{}{})
	fake.iaaSMutex.Unlock()
	if fake.IaaSStub != nil {
		return fake.IaaSStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iaaSReturns.result1
}

func (fake *FakeIClient) IaaSCallCount() int {
	fake.iaaSMutex.RLock()
	defer fake.iaaSMutex.RUnlock()
	return len(fake.iaaSArgsForCall)
}

func (fake *FakeIClient) IaaSReturns(result1 string) {
	fake.IaaSStub = nil
	fake.iaaSReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIClient) IaaSReturnsOnCall(i int, result1 string) {
	fake.IaaSStub = nil
	if fake.iaaSReturnsOnCall == nil {
		fake.iaaSReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iaaSReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIClient) Region() string {
	fake.regionMutex.Lock()
	ret, specificReturn := fake.regionReturnsOnCall[len(fake.regionArgsForCall)]
	fake.regionArgsForCall = append(fake.regionArgsForCall, struct{}{})
	fake.recordInvocation("Region", []interface{}{})
	fake.regionMutex.Unlock()
	if fake.RegionStub != nil {
		return fake.RegionStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.regionReturns.result1
}

func (fake *FakeIClient) RegionCallCount() int {
	fake.regionMutex.RLock()
	defer fake.regionMutex.RUnlock()
	return len(fake.regionArgsForCall)
}

func (fake *FakeIClient) RegionReturns(result1 string) {
	fake.RegionStub = nil
	fake.regionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeIClient) RegionReturnsOnCall(i int, result1 string) {
	fake.RegionStub = nil
	if fake.regionReturnsOnCall == nil {
		fake.regionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.regionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeIClient) DeleteVMsInVPC(vpcID string) error {
	fake.deleteVMsInVPCMutex.Lock()
	ret, specificReturn := fake.deleteVMsInVPCReturnsOnCall[len(fake.deleteVMsInVPCArgsForCall)]
	fake.deleteVMsInVPCArgsForCall = append(fake.deleteVMsInVPCArgsForCall, struct {
		vpcID string
	}{vpcID})
	fake.recordInvocation("DeleteVMsInVPC", []interface{}{vpcID})
	fake.deleteVMsInVPCMutex.Unlock()
	if fake.DeleteVMsInVPCStub != nil {
		return fake.DeleteVMsInVPCStub(vpcID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteVMsInVPCReturns.result1
}

func (fake *FakeIClient) DeleteVMsInVPCCallCount() int {
	fake.deleteVMsInVPCMutex.RLock()
	defer fake.deleteVMsInVPCMutex.RUnlock()
	return len(fake.deleteVMsInVPCArgsForCall)
}

func (fake *FakeIClient) DeleteVMsInVPCArgsForCall(i int) string {
	fake.deleteVMsInVPCMutex.RLock()
	defer fake.deleteVMsInVPCMutex.RUnlock()
	return fake.deleteVMsInVPCArgsForCall[i].vpcID
}

func (fake *FakeIClient) DeleteVMsInVPCReturns(result1 error) {
	fake.DeleteVMsInVPCStub = nil
	fake.deleteVMsInVPCReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) DeleteVMsInVPCReturnsOnCall(i int, result1 error) {
	fake.DeleteVMsInVPCStub = nil
	if fake.deleteVMsInVPCReturnsOnCall == nil {
		fake.deleteVMsInVPCReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteVMsInVPCReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) FindLongestMatchingHostedZone(subDomain string) (string, string, error) {
	fake.findLongestMatchingHostedZoneMutex.Lock()
	ret, specificReturn := fake.findLongestMatchingHostedZoneReturnsOnCall[len(fake.findLongestMatchingHostedZoneArgsForCall)]
	fake.findLongestMatchingHostedZoneArgsForCall = append(fake.findLongestMatchingHostedZoneArgsForCall, struct {
		subDomain string
	}{subDomain})
	fake.recordInvocation("FindLongestMatchingHostedZone", []interface{}{subDomain})
	fake.findLongestMatchingHostedZoneMutex.Unlock()
	if fake.FindLongestMatchingHostedZoneStub != nil {
		return fake.FindLongestMatchingHostedZoneStub(subDomain)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.findLongestMatchingHostedZoneReturns.result1, fake.findLongestMatchingHostedZoneReturns.result2, fake.findLongestMatchingHostedZoneReturns.result3
}

func (fake *FakeIClient) FindLongestMatchingHostedZoneCallCount() int {
	fake.findLongestMatchingHostedZoneMutex.RLock()
	defer fake.findLongestMatchingHostedZoneMutex.RUnlock()
	return len(fake.findLongestMatchingHostedZoneArgsForCall)
}

func (fake *FakeIClient) FindLongestMatchingHostedZoneArgsForCall(i int) string {
	fake.findLongestMatchingHostedZoneMutex.RLock()
	defer fake.findLongestMatchingHostedZoneMutex.RUnlock()
	return fake.findLongestMatchingHostedZoneArgsForCall[i].subDomain
}

func (fake *FakeIClient) FindLongestMatchingHostedZoneReturns(result1 string, result2 string, result3 error) {
	fake.FindLongestMatchingHostedZoneStub = nil
	fake.findLongestMatchingHostedZoneReturns = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIClient) FindLongestMatchingHostedZoneReturnsOnCall(i int, result1 string, result2 string, result3 error) {
	fake.FindLongestMatchingHostedZoneStub = nil
	if fake.findLongestMatchingHostedZoneReturnsOnCall == nil {
		fake.findLongestMatchingHostedZoneReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
			result3 error
		})
	}
	fake.findLongestMatchingHostedZoneReturnsOnCall[i] = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIClient) MockProvider(arg1 interface{}) {
	fake.mockProviderMutex.Lock()
	fake.mockProviderArgsForCall = append(fake.mockProviderArgsForCall, struct {
		arg1 interface{}
	}{arg1})
	fake.recordInvocation("MockProvider", []interface{}{arg1})
	fake.mockProviderMutex.Unlock()
	if fake.MockProviderStub != nil {
		fake.MockProviderStub(arg1)
	}
}

func (fake *FakeIClient) MockProviderCallCount() int {
	fake.mockProviderMutex.RLock()
	defer fake.mockProviderMutex.RUnlock()
	return len(fake.mockProviderArgsForCall)
}

func (fake *FakeIClient) MockProviderArgsForCall(i int) interface{} {
	fake.mockProviderMutex.RLock()
	defer fake.mockProviderMutex.RUnlock()
	return fake.mockProviderArgsForCall[i].arg1
}

func (fake *FakeIClient) DeleteVersionedBucket(name string) error {
	fake.deleteVersionedBucketMutex.Lock()
	ret, specificReturn := fake.deleteVersionedBucketReturnsOnCall[len(fake.deleteVersionedBucketArgsForCall)]
	fake.deleteVersionedBucketArgsForCall = append(fake.deleteVersionedBucketArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("DeleteVersionedBucket", []interface{}{name})
	fake.deleteVersionedBucketMutex.Unlock()
	if fake.DeleteVersionedBucketStub != nil {
		return fake.DeleteVersionedBucketStub(name)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteVersionedBucketReturns.result1
}

func (fake *FakeIClient) DeleteVersionedBucketCallCount() int {
	fake.deleteVersionedBucketMutex.RLock()
	defer fake.deleteVersionedBucketMutex.RUnlock()
	return len(fake.deleteVersionedBucketArgsForCall)
}

func (fake *FakeIClient) DeleteVersionedBucketArgsForCall(i int) string {
	fake.deleteVersionedBucketMutex.RLock()
	defer fake.deleteVersionedBucketMutex.RUnlock()
	return fake.deleteVersionedBucketArgsForCall[i].name
}

func (fake *FakeIClient) DeleteVersionedBucketReturns(result1 error) {
	fake.DeleteVersionedBucketStub = nil
	fake.deleteVersionedBucketReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) DeleteVersionedBucketReturnsOnCall(i int, result1 error) {
	fake.DeleteVersionedBucketStub = nil
	if fake.deleteVersionedBucketReturnsOnCall == nil {
		fake.deleteVersionedBucketReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteVersionedBucketReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) DeleteFile(bucket string, path string) error {
	fake.deleteFileMutex.Lock()
	ret, specificReturn := fake.deleteFileReturnsOnCall[len(fake.deleteFileArgsForCall)]
	fake.deleteFileArgsForCall = append(fake.deleteFileArgsForCall, struct {
		bucket string
		path   string
	}{bucket, path})
	fake.recordInvocation("DeleteFile", []interface{}{bucket, path})
	fake.deleteFileMutex.Unlock()
	if fake.DeleteFileStub != nil {
		return fake.DeleteFileStub(bucket, path)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteFileReturns.result1
}

func (fake *FakeIClient) DeleteFileCallCount() int {
	fake.deleteFileMutex.RLock()
	defer fake.deleteFileMutex.RUnlock()
	return len(fake.deleteFileArgsForCall)
}

func (fake *FakeIClient) DeleteFileArgsForCall(i int) (string, string) {
	fake.deleteFileMutex.RLock()
	defer fake.deleteFileMutex.RUnlock()
	return fake.deleteFileArgsForCall[i].bucket, fake.deleteFileArgsForCall[i].path
}

func (fake *FakeIClient) DeleteFileReturns(result1 error) {
	fake.DeleteFileStub = nil
	fake.deleteFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) DeleteFileReturnsOnCall(i int, result1 error) {
	fake.DeleteFileStub = nil
	if fake.deleteFileReturnsOnCall == nil {
		fake.deleteFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) EnsureBucketExists(name string) error {
	fake.ensureBucketExistsMutex.Lock()
	ret, specificReturn := fake.ensureBucketExistsReturnsOnCall[len(fake.ensureBucketExistsArgsForCall)]
	fake.ensureBucketExistsArgsForCall = append(fake.ensureBucketExistsArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("EnsureBucketExists", []interface{}{name})
	fake.ensureBucketExistsMutex.Unlock()
	if fake.EnsureBucketExistsStub != nil {
		return fake.EnsureBucketExistsStub(name)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.ensureBucketExistsReturns.result1
}

func (fake *FakeIClient) EnsureBucketExistsCallCount() int {
	fake.ensureBucketExistsMutex.RLock()
	defer fake.ensureBucketExistsMutex.RUnlock()
	return len(fake.ensureBucketExistsArgsForCall)
}

func (fake *FakeIClient) EnsureBucketExistsArgsForCall(i int) string {
	fake.ensureBucketExistsMutex.RLock()
	defer fake.ensureBucketExistsMutex.RUnlock()
	return fake.ensureBucketExistsArgsForCall[i].name
}

func (fake *FakeIClient) EnsureBucketExistsReturns(result1 error) {
	fake.EnsureBucketExistsStub = nil
	fake.ensureBucketExistsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) EnsureBucketExistsReturnsOnCall(i int, result1 error) {
	fake.EnsureBucketExistsStub = nil
	if fake.ensureBucketExistsReturnsOnCall == nil {
		fake.ensureBucketExistsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ensureBucketExistsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) EnsureFileExists(bucket string, path string, defaultContents []byte) ([]byte, bool, error) {
	var defaultContentsCopy []byte
	if defaultContents != nil {
		defaultContentsCopy = make([]byte, len(defaultContents))
		copy(defaultContentsCopy, defaultContents)
	}
	fake.ensureFileExistsMutex.Lock()
	ret, specificReturn := fake.ensureFileExistsReturnsOnCall[len(fake.ensureFileExistsArgsForCall)]
	fake.ensureFileExistsArgsForCall = append(fake.ensureFileExistsArgsForCall, struct {
		bucket          string
		path            string
		defaultContents []byte
	}{bucket, path, defaultContentsCopy})
	fake.recordInvocation("EnsureFileExists", []interface{}{bucket, path, defaultContentsCopy})
	fake.ensureFileExistsMutex.Unlock()
	if fake.EnsureFileExistsStub != nil {
		return fake.EnsureFileExistsStub(bucket, path, defaultContents)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.ensureFileExistsReturns.result1, fake.ensureFileExistsReturns.result2, fake.ensureFileExistsReturns.result3
}

func (fake *FakeIClient) EnsureFileExistsCallCount() int {
	fake.ensureFileExistsMutex.RLock()
	defer fake.ensureFileExistsMutex.RUnlock()
	return len(fake.ensureFileExistsArgsForCall)
}

func (fake *FakeIClient) EnsureFileExistsArgsForCall(i int) (string, string, []byte) {
	fake.ensureFileExistsMutex.RLock()
	defer fake.ensureFileExistsMutex.RUnlock()
	return fake.ensureFileExistsArgsForCall[i].bucket, fake.ensureFileExistsArgsForCall[i].path, fake.ensureFileExistsArgsForCall[i].defaultContents
}

func (fake *FakeIClient) EnsureFileExistsReturns(result1 []byte, result2 bool, result3 error) {
	fake.EnsureFileExistsStub = nil
	fake.ensureFileExistsReturns = struct {
		result1 []byte
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIClient) EnsureFileExistsReturnsOnCall(i int, result1 []byte, result2 bool, result3 error) {
	fake.EnsureFileExistsStub = nil
	if fake.ensureFileExistsReturnsOnCall == nil {
		fake.ensureFileExistsReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 bool
			result3 error
		})
	}
	fake.ensureFileExistsReturnsOnCall[i] = struct {
		result1 []byte
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIClient) HasFile(bucket string, path string) (bool, error) {
	fake.hasFileMutex.Lock()
	ret, specificReturn := fake.hasFileReturnsOnCall[len(fake.hasFileArgsForCall)]
	fake.hasFileArgsForCall = append(fake.hasFileArgsForCall, struct {
		bucket string
		path   string
	}{bucket, path})
	fake.recordInvocation("HasFile", []interface{}{bucket, path})
	fake.hasFileMutex.Unlock()
	if fake.HasFileStub != nil {
		return fake.HasFileStub(bucket, path)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.hasFileReturns.result1, fake.hasFileReturns.result2
}

func (fake *FakeIClient) HasFileCallCount() int {
	fake.hasFileMutex.RLock()
	defer fake.hasFileMutex.RUnlock()
	return len(fake.hasFileArgsForCall)
}

func (fake *FakeIClient) HasFileArgsForCall(i int) (string, string) {
	fake.hasFileMutex.RLock()
	defer fake.hasFileMutex.RUnlock()
	return fake.hasFileArgsForCall[i].bucket, fake.hasFileArgsForCall[i].path
}

func (fake *FakeIClient) HasFileReturns(result1 bool, result2 error) {
	fake.HasFileStub = nil
	fake.hasFileReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) HasFileReturnsOnCall(i int, result1 bool, result2 error) {
	fake.HasFileStub = nil
	if fake.hasFileReturnsOnCall == nil {
		fake.hasFileReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.hasFileReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) LoadFile(bucket string, path string) ([]byte, error) {
	fake.loadFileMutex.Lock()
	ret, specificReturn := fake.loadFileReturnsOnCall[len(fake.loadFileArgsForCall)]
	fake.loadFileArgsForCall = append(fake.loadFileArgsForCall, struct {
		bucket string
		path   string
	}{bucket, path})
	fake.recordInvocation("LoadFile", []interface{}{bucket, path})
	fake.loadFileMutex.Unlock()
	if fake.LoadFileStub != nil {
		return fake.LoadFileStub(bucket, path)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.loadFileReturns.result1, fake.loadFileReturns.result2
}

func (fake *FakeIClient) LoadFileCallCount() int {
	fake.loadFileMutex.RLock()
	defer fake.loadFileMutex.RUnlock()
	return len(fake.loadFileArgsForCall)
}

func (fake *FakeIClient) LoadFileArgsForCall(i int) (string, string) {
	fake.loadFileMutex.RLock()
	defer fake.loadFileMutex.RUnlock()
	return fake.loadFileArgsForCall[i].bucket, fake.loadFileArgsForCall[i].path
}

func (fake *FakeIClient) LoadFileReturns(result1 []byte, result2 error) {
	fake.LoadFileStub = nil
	fake.loadFileReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) LoadFileReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.LoadFileStub = nil
	if fake.loadFileReturnsOnCall == nil {
		fake.loadFileReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.loadFileReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeIClient) WriteFile(bucket string, path string, contents []byte) error {
	var contentsCopy []byte
	if contents != nil {
		contentsCopy = make([]byte, len(contents))
		copy(contentsCopy, contents)
	}
	fake.writeFileMutex.Lock()
	ret, specificReturn := fake.writeFileReturnsOnCall[len(fake.writeFileArgsForCall)]
	fake.writeFileArgsForCall = append(fake.writeFileArgsForCall, struct {
		bucket   string
		path     string
		contents []byte
	}{bucket, path, contentsCopy})
	fake.recordInvocation("WriteFile", []interface{}{bucket, path, contentsCopy})
	fake.writeFileMutex.Unlock()
	if fake.WriteFileStub != nil {
		return fake.WriteFileStub(bucket, path, contents)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.writeFileReturns.result1
}

func (fake *FakeIClient) WriteFileCallCount() int {
	fake.writeFileMutex.RLock()
	defer fake.writeFileMutex.RUnlock()
	return len(fake.writeFileArgsForCall)
}

func (fake *FakeIClient) WriteFileArgsForCall(i int) (string, string, []byte) {
	fake.writeFileMutex.RLock()
	defer fake.writeFileMutex.RUnlock()
	return fake.writeFileArgsForCall[i].bucket, fake.writeFileArgsForCall[i].path, fake.writeFileArgsForCall[i].contents
}

func (fake *FakeIClient) WriteFileReturns(result1 error) {
	fake.WriteFileStub = nil
	fake.writeFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) WriteFileReturnsOnCall(i int, result1 error) {
	fake.WriteFileStub = nil
	if fake.writeFileReturnsOnCall == nil {
		fake.writeFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writeFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.iaaSMutex.RLock()
	defer fake.iaaSMutex.RUnlock()
	fake.regionMutex.RLock()
	defer fake.regionMutex.RUnlock()
	fake.deleteVMsInVPCMutex.RLock()
	defer fake.deleteVMsInVPCMutex.RUnlock()
	fake.findLongestMatchingHostedZoneMutex.RLock()
	defer fake.findLongestMatchingHostedZoneMutex.RUnlock()
	fake.mockProviderMutex.RLock()
	defer fake.mockProviderMutex.RUnlock()
	fake.deleteVersionedBucketMutex.RLock()
	defer fake.deleteVersionedBucketMutex.RUnlock()
	fake.deleteFileMutex.RLock()
	defer fake.deleteFileMutex.RUnlock()
	fake.ensureBucketExistsMutex.RLock()
	defer fake.ensureBucketExistsMutex.RUnlock()
	fake.ensureFileExistsMutex.RLock()
	defer fake.ensureFileExistsMutex.RUnlock()
	fake.hasFileMutex.RLock()
	defer fake.hasFileMutex.RUnlock()
	fake.loadFileMutex.RLock()
	defer fake.loadFileMutex.RUnlock()
	fake.writeFileMutex.RLock()
	defer fake.writeFileMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ iaas.IClient = new(FakeIClient)
